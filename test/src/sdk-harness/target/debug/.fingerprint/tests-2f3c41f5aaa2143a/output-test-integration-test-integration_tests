{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/auth/mod.rs","byte_start":125,"byte_end":237,"line_start":6,"line_end":9,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    AuthContract,","highlight_start":1,"highlight_end":18},{"text":"    \"test_artifacts/auth_testing_contract/out/debug/auth_testing_contract-abi.json\"","highlight_start":1,"highlight_end":84},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/auth_testing_contract/out/debug/auth_testing_contract-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/auth/mod.rs:6:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    AuthContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_artifacts/auth_testing_contract/out/debug/auth_testing_contract-abi.json\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/auth_testing_contract/out/debug/auth_testing_contract-abi.json\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Caused by:\u001b[0m\n\u001b[0m              No such file or directory (os error 2)\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Stack backtrace:\u001b[0m\n\u001b[0m             0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m             1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m             2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m             3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m             4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m             5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m             6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m             7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m             8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m             9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m            10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m            11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m            12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m            13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m            14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m            15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m            16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m            17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m            18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m            19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m            20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m            21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m            22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m            23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m            24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m            25: ___rust_try\u001b[0m\n\u001b[0m            26: std::panicking::try\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m            27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m            28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m            29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m            30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m            31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m            32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m            33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m            34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m            35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m            36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m            37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m            39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m            42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m            43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/call_frames/mod.rs","byte_start":147,"byte_end":248,"line_start":7,"line_end":10,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    CallFramesTestContract,","highlight_start":1,"highlight_end":28},{"text":"    \"test_projects/call_frames/out/debug/call_frames-abi.json\"","highlight_start":1,"highlight_end":63},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/call_frames/out/debug/call_frames-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/call_frames/mod.rs:7:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    CallFramesTestContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_projects/call_frames/out/debug/call_frames-abi.json\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/call_frames/out/debug/call_frames-abi.json\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Caused by:\u001b[0m\n\u001b[0m               No such file or directory (os error 2)\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m              1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m              2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m              3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m              4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m              5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m              6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m              7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m              8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m              9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m             10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m             11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m             12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m             13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m             14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m             15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m             16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m             17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m             18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m             19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m             20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m             21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m             22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m             23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m             24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m             25: ___rust_try\u001b[0m\n\u001b[0m             26: std::panicking::try\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m             27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m             28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m             29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m             30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m             31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m             32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m             35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m             36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m             37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m             39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m             43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":122,"byte_end":213,"line_start":6,"line_end":9,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    TestContextContract,","highlight_start":1,"highlight_end":25},{"text":"    \"test_projects/context/out/debug/context-abi.json\",","highlight_start":1,"highlight_end":56},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/context/out/debug/context-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:6:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TestContextContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_projects/context/out/debug/context-abi.json\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/context/out/debug/context-abi.json\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Caused by:\u001b[0m\n\u001b[0m              No such file or directory (os error 2)\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Stack backtrace:\u001b[0m\n\u001b[0m             0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m             1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m             2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m             3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m             4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m             5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m             6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m             7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m             8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m             9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m            10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m            11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m            12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m            13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m            14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m            15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m            16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m            17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m            18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m            19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m            20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m            21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m            22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m            23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m            24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m            25: ___rust_try\u001b[0m\n\u001b[0m            26: std::panicking::try\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m            27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m            28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m            29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m            30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m            31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m            32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m            33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m            34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m            35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m            36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m            37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m            39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m            42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m            43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":215,"byte_end":345,"line_start":10,"line_end":13,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    TestContextCallerContract,","highlight_start":1,"highlight_end":31},{"text":"    \"test_artifacts/context_caller_contract/out/debug/context_caller_contract-abi.json\",","highlight_start":1,"highlight_end":89},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/context_caller_contract/out/debug/context_caller_contract-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:10:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TestContextCallerContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_artifacts/context_caller_contract/out/debug/context_caller_contract-abi.json\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/context_caller_contract/out/debug/context_caller_contract-abi.json\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Caused by:\u001b[0m\n\u001b[0m               No such file or directory (os error 2)\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m              1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m              2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m              3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m              4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m              5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m              6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m              7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m              8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m              9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m             10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m             11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m             12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m             13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m             14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m             15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m             16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m             17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m             18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m             19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m             20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m             21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m             22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m             23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m             24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m             25: ___rust_try\u001b[0m\n\u001b[0m             26: std::panicking::try\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m             27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m             28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m             29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m             30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m             31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m             32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m             35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m             36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m             37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m             39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m             43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":347,"byte_end":430,"line_start":14,"line_end":17,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    FuelCoin,","highlight_start":1,"highlight_end":14},{"text":"    \"test_projects/token_ops/out/debug/token_ops-abi.json\"","highlight_start":1,"highlight_end":59},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/token_ops/out/debug/token_ops-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:14:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    FuelCoin,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_projects/token_ops/out/debug/token_ops-abi.json\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/token_ops/out/debug/token_ops-abi.json\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Caused by:\u001b[0m\n\u001b[0m               No such file or directory (os error 2)\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m              1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m              2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m              3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m              4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m              5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m              6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m              7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m              8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m              9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m             10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m             11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m             12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m             13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m             14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m             15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m             16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m             17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m             18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m             19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m             20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m             21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m             22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m             23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m             24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m             25: ___rust_try\u001b[0m\n\u001b[0m             26: std::panicking::try\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m             27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m             28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m             29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m             30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m             31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m             32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m             35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m             36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m             37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m             39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m             43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":149,"byte_end":280,"line_start":6,"line_end":9,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    AttackerContract,","highlight_start":1,"highlight_end":22},{"text":"    \"test_artifacts/reentrancy_attacker_contract/out/debug/reentrancy_attacker_contract-abi.json\",","highlight_start":1,"highlight_end":99},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/reentrancy_attacker_contract/out/debug/reentrancy_attacker_contract-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:6:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    AttackerContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_artifacts/reentrancy_attacker_contract/out/debug/reentrancy_attacker_contract-abi.json\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/reentrancy_attacker_contract/out/debug/reentrancy_attacker_contract-abi.json\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Caused by:\u001b[0m\n\u001b[0m              No such file or directory (os error 2)\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Stack backtrace:\u001b[0m\n\u001b[0m             0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m             1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m             2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m             3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m             4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m             5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m             6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m             7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m             8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m             9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m            10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m            11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m            12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m            13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m            14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m            15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m            16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m            17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m            18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m            19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m            20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m            21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m            22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m            23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m            24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m            25: ___rust_try\u001b[0m\n\u001b[0m            26: std::panicking::try\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m            27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m            28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m            29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m            30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m            31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m            32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m            33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m            34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m            35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m            36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m            37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m            39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m            42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m            43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":283,"byte_end":408,"line_start":11,"line_end":14,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    TargetContract,","highlight_start":1,"highlight_end":20},{"text":"    \"test_artifacts/reentrancy_target_contract/out/debug/reentrancy_target_contract-abi.json\",","highlight_start":1,"highlight_end":95},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/reentrancy_target_contract/out/debug/reentrancy_target_contract-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:11:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TargetContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_artifacts/reentrancy_target_contract/out/debug/reentrancy_target_contract-abi.json\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/reentrancy_target_contract/out/debug/reentrancy_target_contract-abi.json\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Caused by:\u001b[0m\n\u001b[0m               No such file or directory (os error 2)\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m              1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m              2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m              3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m              4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m              5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m              6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m              7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m              8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m              9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m             10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m             11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m             12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m             13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m             14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m             15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m             16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m             17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m             18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m             19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m             20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m             21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m             22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m             23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m             24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m             25: ___rust_try\u001b[0m\n\u001b[0m             26: std::panicking::try\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m             27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m             28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m             29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m             30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m             31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m             32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m             35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m             36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m             37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m             39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m             43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":133,"byte_end":230,"line_start":7,"line_end":10,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    TestRegistersContract,","highlight_start":1,"highlight_end":27},{"text":"    \"test_projects/registers/out/debug/registers-abi.json\",","highlight_start":1,"highlight_end":60},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/registers/out/debug/registers-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:7:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TestRegistersContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_projects/registers/out/debug/registers-abi.json\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/registers/out/debug/registers-abi.json\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Caused by:\u001b[0m\n\u001b[0m               No such file or directory (os error 2)\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m              1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m              2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m              3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m              4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m              5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m              6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m              7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m              8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m              9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m             10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m             11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m             12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m             13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m             14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m             15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m             16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m             17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m             18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m             19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m             20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m             21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m             22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m             23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m             24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m             25: ___rust_try\u001b[0m\n\u001b[0m             26: std::panicking::try\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m             27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m             28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m             29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m             30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m             31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m             32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m             35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m             36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m             37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m             39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m             43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":134,"byte_end":229,"line_start":6,"line_end":9,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    TestFuelCoinContract,","highlight_start":1,"highlight_end":26},{"text":"    \"test_projects/token_ops/out/debug/token_ops-abi.json\"","highlight_start":1,"highlight_end":59},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/token_ops/out/debug/token_ops-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:6:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TestFuelCoinContract,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_projects/token_ops/out/debug/token_ops-abi.json\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_projects/token_ops/out/debug/token_ops-abi.json\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Caused by:\u001b[0m\n\u001b[0m              No such file or directory (os error 2)\u001b[0m\n\u001b[0m          \u001b[0m\n\u001b[0m          Stack backtrace:\u001b[0m\n\u001b[0m             0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m             1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m             2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m             3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m             4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m             5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m             6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m             7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m             8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m             9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m            10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m            11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                       at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m            12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m            13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m            14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m            15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m            16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m            17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m            18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m            19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m            20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m            21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m            22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m            23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m            24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m            25: ___rust_try\u001b[0m\n\u001b[0m            26: std::panicking::try\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m            27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m            28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m            29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                       at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m            30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m            31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m            32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m            33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m            34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m            35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m            36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m            37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m            39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m            41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m            42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m            43: __pthread_start\u001b[0m\n\n"}
{"message":"proc macro panicked","code":null,"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":203,"byte_end":298,"line_start":8,"line_end":11,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"abigen!(","highlight_start":1,"highlight_end":9},{"text":"    TxContractTest,","highlight_start":1,"highlight_end":20},{"text":"    \"test_artifacts/tx_contract/out/debug/tx_contract-abi.json\",","highlight_start":1,"highlight_end":65},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/tx_contract/out/debug/tx_contract-abi.json\n\nCaused by:\n    No such file or directory (os error 2)\n\nStack backtrace:\n   0: std::backtrace_rs::backtrace::libunwind::trace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\n   1: std::backtrace_rs::backtrace::trace_unsynchronized\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n   2: std::backtrace::Backtrace::create\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\n   3: std::backtrace::Backtrace::capture\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\n   4: <E as anyhow::context::ext::StdError>::ext_context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\n   5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\n   6: core::result::Result<T,E>::map_err\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\n   7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\n   8: fuels_core::source::get_local_contract\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\n   9: fuels_core::source::Source::get\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\n  10: fuels_core::code_gen::abigen::Abigen::new\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\n  11: fuels_abigen_macro::abigen\n             at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\n  12: core::ops::function::FnOnce::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\n  13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\n  14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\n  15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\n  16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\n  17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\n  18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\n  19: std::thread::local::LocalKey<T>::try_with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\n  20: std::thread::local::LocalKey<T>::with\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\n  21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\n  22: proc_macro::bridge::client::run_client::{{closure}}\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\n  23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\n  24: std::panicking::try::do_call\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\n  25: ___rust_try\n  26: std::panicking::try\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\n  27: std::panic::catch_unwind\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\n  28: proc_macro::bridge::client::run_client\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\n  29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\n             at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\n  30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\n  31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\n  32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  33: <rustc_expand::expand::MacroExpander>::expand_crate\n  34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\n  35: rustc_interface::passes::configure_and_expand\n  36: <rustc_interface::queries::Queries>::expansion\n  37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\n  38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\n  39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\n  41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  42: std::sys::unix::thread::Thread::new::thread_start\n  43: __pthread_start","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc macro panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:8:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mabigen!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TxContractTest,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"test_artifacts/tx_contract/out/debug/tx_contract-abi.json\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: failed to read artifact JSON file with path /Users/rashad/Development/repos/sway/test/src/sdk-harness/test_artifacts/tx_contract/out/debug/tx_contract-abi.json\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Caused by:\u001b[0m\n\u001b[0m               No such file or directory (os error 2)\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: std::backtrace_rs::backtrace::libunwind::trace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\u001b[0m\n\u001b[0m              1: std::backtrace_rs::backtrace::trace_unsynchronized\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\u001b[0m\n\u001b[0m              2: std::backtrace::Backtrace::create\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:328:13\u001b[0m\n\u001b[0m              3: std::backtrace::Backtrace::capture\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/backtrace.rs:296:9\u001b[0m\n\u001b[0m              4: <E as anyhow::context::ext::StdError>::ext_context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:27:29\u001b[0m\n\u001b[0m              5: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context::{{closure}}\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:30\u001b[0m\n\u001b[0m              6: core::result::Result<T,E>::map_err\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/result.rs:855:27\u001b[0m\n\u001b[0m              7: anyhow::context::<impl anyhow::Context<T,E> for core::result::Result<T,E>>::context\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.57/src/context.rs:50:9\u001b[0m\n\u001b[0m              8: fuels_core::source::get_local_contract\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:92:16\u001b[0m\n\u001b[0m              9: fuels_core::source::Source::get\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/source.rs:70:36\u001b[0m\n\u001b[0m             10: fuels_core::code_gen::abigen::Abigen::new\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-core-0.10.1/src/code_gen/abigen.rs:41:61\u001b[0m\n\u001b[0m             11: fuels_abigen_macro::abigen\u001b[0m\n\u001b[0m                        at /Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-abigen-macro-0.10.1/src/lib.rs:15:13\u001b[0m\n\u001b[0m             12: core::ops::function::FnOnce::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/ops/function.rs:248:5\u001b[0m\n\u001b[0m             13: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:40\u001b[0m\n\u001b[0m             14: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:376:26\u001b[0m\n\u001b[0m             15: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:33\u001b[0m\n\u001b[0m             16: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:75:9\u001b[0m\n\u001b[0m             17: proc_macro::bridge::scoped_cell::ScopedCell<T>::set\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/scoped_cell.rs:80:9\u001b[0m\n\u001b[0m             18: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:35\u001b[0m\n\u001b[0m             19: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:442:16\u001b[0m\n\u001b[0m             20: std::thread::local::LocalKey<T>::with\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/thread/local.rs:418:9\u001b[0m\n\u001b[0m             21: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:324:9\u001b[0m\n\u001b[0m             22: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:369:9\u001b[0m\n\u001b[0m             23: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/core/src/panic/unwind_safe.rs:271:9\u001b[0m\n\u001b[0m             24: std::panicking::try::do_call\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:492:40\u001b[0m\n\u001b[0m             25: ___rust_try\u001b[0m\n\u001b[0m             26: std::panicking::try\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panicking.rs:456:19\u001b[0m\n\u001b[0m             27: std::panic::catch_unwind\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/std/src/panic.rs:137:14\u001b[0m\n\u001b[0m             28: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:368:5\u001b[0m\n\u001b[0m             29: proc_macro::bridge::client::Client<fn(proc_macro::TokenStream) .> proc_macro::TokenStream>::expand1::run\u001b[0m\n\u001b[0m                        at /rustc/8f36334ca939a67cce3f37f24953ff6f2d3f3d33/library/proc_macro/src/bridge/client.rs:409:13\u001b[0m\n\u001b[0m             30: proc_macro::bridge::server::run_server::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, proc_macro::bridge::Marked<rustc_ast::tokenstream::TokenStream, proc_macro::bridge::client::TokenStream>, fn(proc_macro::TokenStream) -> proc_macro::TokenStream, proc_macro::bridge::server::SameThread>\u001b[0m\n\u001b[0m             31: <rustc_expand::proc_macro::BangProcMacro as rustc_expand::base::ProcMacro>::expand\u001b[0m\n\u001b[0m             32: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             33: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             34: <rustc_session::session::Session>::time::<core::result::Result<rustc_ast::ast::Crate, rustc_errors::ErrorGuaranteed>, rustc_interface::passes::configure_and_expand::{closure#1}>\u001b[0m\n\u001b[0m             35: rustc_interface::passes::configure_and_expand\u001b[0m\n\u001b[0m             36: <rustc_interface::queries::Queries>::expansion\u001b[0m\n\u001b[0m             37: <rustc_interface::interface::Compiler>::enter::<rustc_driver::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             38: rustc_span::with_source_map::<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_interface::interface::create_compiler_and_run<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#1}>\u001b[0m\n\u001b[0m             39: <scoped_tls::ScopedKey<rustc_span::SessionGlobals>>::set::<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             40: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             41: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_pool_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_errors::ErrorGuaranteed>, rustc_driver::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#0}, core::result::Result<(), rustc_errors::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             42: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m             43: __pthread_start\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `AuthContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/auth/mod.rs","byte_start":2045,"byte_end":2057,"line_start":76,"line_end":76,"column_start":22,"column_end":34,"is_primary":true,"text":[{"text":"    let instance_1 = AuthContract::new(id_1.to_string(), provider.clone(), wallet.clone());","highlight_start":22,"highlight_end":34}],"label":"use of undeclared type `AuthContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `AuthContract`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/auth/mod.rs:76:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance_1 = AuthContract::new(id_1.to_string(), provider.clone(), wallet.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `AuthContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `CallFramesTestContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/call_frames/mod.rs","byte_start":729,"byte_end":751,"line_start":21,"line_end":21,"column_start":20,"column_end":42,"is_primary":true,"text":[{"text":"    let instance = CallFramesTestContract::new(id.to_string(), provider, wallet);","highlight_start":20,"highlight_end":42}],"label":"use of undeclared type `CallFramesTestContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `CallFramesTestContract`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/call_frames/mod.rs:21:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = CallFramesTestContract::new(id.to_string(), provider, wallet);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `CallFramesTestContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `TestContextCallerContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":1236,"byte_end":1261,"line_start":43,"line_end":43,"column_start":9,"column_end":34,"is_primary":true,"text":[{"text":"        TestContextCallerContract::new(id_2.to_string(), provider.clone(), wallet.clone());","highlight_start":9,"highlight_end":34}],"label":"use of undeclared type `TestContextCallerContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `TestContextCallerContract`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:43:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        TestContextCallerContract::new(id_2.to_string(), provider.clone(), wallet.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `TestContextCallerContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `TestContextContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":1341,"byte_end":1360,"line_start":44,"line_end":44,"column_start":22,"column_end":41,"is_primary":true,"text":[{"text":"    let instance_1 = TestContextContract::new(id_1.to_string(), provider.clone(), wallet.clone());","highlight_start":22,"highlight_end":41}],"label":"use of undeclared type `TestContextContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `TestContextContract`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:44:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance_1 = TestContextContract::new(id_1.to_string(), provider.clone(), wallet.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `TestContextContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `AttackerContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":2912,"byte_end":2928,"line_start":93,"line_end":93,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"    let instance = AttackerContract::new(id.to_string(), provider, wallet);","highlight_start":20,"highlight_end":36}],"label":"use of undeclared type `AttackerContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `AttackerContract`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:93:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = AttackerContract::new(id.to_string(), provider, wallet);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `AttackerContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `TargetContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":3447,"byte_end":3461,"line_start":109,"line_end":109,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"    let instance = TargetContract::new(id.to_string(), provider, wallet);","highlight_start":20,"highlight_end":34}],"label":"use of undeclared type `TargetContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `TargetContract`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:109:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = TargetContract::new(id.to_string(), provider, wallet);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `TargetContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `TestRegistersContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":873,"byte_end":894,"line_start":26,"line_end":26,"column_start":5,"column_end":26,"is_primary":true,"text":[{"text":"    TestRegistersContract::new(id.to_string(), provider, wallet)","highlight_start":5,"highlight_end":26}],"label":"use of undeclared type `TestRegistersContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `TestRegistersContract`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:26:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    TestRegistersContract::new(id.to_string(), provider, wallet)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `TestRegistersContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `TestFuelCoinContract`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":5529,"byte_end":5549,"line_start":195,"line_end":195,"column_start":29,"column_end":49,"is_primary":true,"text":[{"text":"    let fuelcoin_instance = TestFuelCoinContract::new(fuelcoin_id.to_string(), provider, wallet);","highlight_start":29,"highlight_end":49}],"label":"use of undeclared type `TestFuelCoinContract`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `TestFuelCoinContract`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:195:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let fuelcoin_instance = TestFuelCoinContract::new(fuelcoin_id.to_string(), provider, wallet);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `TestFuelCoinContract`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `TxContractTest`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":765,"byte_end":779,"line_start":23,"line_end":23,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"    let instance = TxContractTest::new(contract_id.to_string(), provider.clone(), wallet.clone());","highlight_start":20,"highlight_end":34}],"label":"use of undeclared type `TxContractTest`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `TxContractTest`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:23:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = TxContractTest::new(contract_id.to_string(), provider.clone(), wallet.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `TxContractTest`\u001b[0m\n\n"}
{"message":"cannot find type `AuthContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-contract-0.10.1/src/contract.rs","byte_start":1239,"byte_end":1258,"line_start":34,"line_end":34,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Contract {","highlight_start":1,"highlight_end":20}],"label":"similarly named struct `Contract` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/auth/mod.rs","byte_start":1243,"byte_end":1255,"line_start":50,"line_end":50,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    AuthContract,","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"test_projects/auth/mod.rs","byte_start":1243,"byte_end":1255,"line_start":50,"line_end":50,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    AuthContract,","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":"Contract","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AuthContract` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/auth/mod.rs:50:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    AuthContract,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a struct with a similar name exists: `Contract`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/rashad/.cargo/registry/src/github.com-1ecc6299db9ec823/fuels-contract-0.10.1/src/contract.rs:34:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Contract {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12msimilarly named struct `Contract` defined here\u001b[0m\n\n"}
{"message":"cannot find type `CallFramesTestContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/call_frames/mod.rs","byte_start":291,"byte_end":313,"line_start":12,"line_end":12,"column_start":41,"column_end":63,"is_primary":true,"text":[{"text":"async fn get_call_frames_instance() -> (CallFramesTestContract, ContractId) {","highlight_start":41,"highlight_end":63}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `CallFramesTestContract` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/call_frames/mod.rs:12:41\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0masync fn get_call_frames_instance() -> (CallFramesTestContract, ContractId) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `TestContextContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":467,"byte_end":486,"line_start":20,"line_end":20,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"    TestContextContract,","highlight_start":5,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `TestContextContract` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:20:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    TestContextContract,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `TestContextCallerContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":508,"byte_end":533,"line_start":22,"line_end":22,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"    TestContextCallerContract,","highlight_start":5,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `TestContextCallerContract` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:22:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    TestContextCallerContract,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `AttackerContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":2520,"byte_end":2536,"line_start":82,"line_end":82,"column_start":7,"column_end":23,"is_primary":true,"text":[{"text":") -> (AttackerContract, ContractId) {","highlight_start":7,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AttackerContract` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:82:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m) -> (AttackerContract, ContractId) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `TargetContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":3061,"byte_end":3075,"line_start":98,"line_end":98,"column_start":70,"column_end":84,"is_primary":true,"text":[{"text":"async fn get_target_instance(provider: Provider, wallet: Wallet) -> (TargetContract, ContractId) {","highlight_start":70,"highlight_end":84}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `TargetContract` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:98:70\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0masync fn get_target_instance(provider: Provider, wallet: Wallet) -> (TargetContract, ContractId) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `TestRegistersContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":467,"byte_end":488,"line_start":16,"line_end":16,"column_start":46,"column_end":67,"is_primary":true,"text":[{"text":"async fn deploy_test_registers_instance() -> TestRegistersContract {","highlight_start":46,"highlight_end":67}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `TestRegistersContract` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:16:46\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0masync fn deploy_test_registers_instance() -> TestRegistersContract {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `TestFuelCoinContract` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":5161,"byte_end":5181,"line_start":186,"line_end":186,"column_start":7,"column_end":27,"is_primary":true,"text":[{"text":") -> (TestFuelCoinContract, ContractId) {","highlight_start":7,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `TestFuelCoinContract` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:186:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m) -> (TestFuelCoinContract, ContractId) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `TxContractTest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":330,"byte_end":344,"line_start":13,"line_end":13,"column_start":30,"column_end":44,"is_primary":true,"text":[{"text":"async fn get_contracts() -> (TxContractTest, ContractId, Wallet) {","highlight_start":30,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `TxContractTest` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:13:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0masync fn get_contracts() -> (TxContractTest, ContractId, Wallet) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/auth/mod.rs","byte_start":415,"byte_end":442,"line_start":17,"line_end":17,"column_start":9,"column_end":36,"is_primary":false,"text":[{"text":"    let (auth_instance, _, _, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":36}],"label":"consider giving this pattern the explicit type `(_, _, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/auth/mod.rs","byte_start":485,"byte_end":498,"line_start":18,"line_end":18,"column_start":18,"column_end":31,"is_primary":true,"text":[{"text":"    let result = auth_instance.is_caller_external().call().await.unwrap();","highlight_start":18,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/auth/mod.rs:18:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (auth_instance, _, _, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = auth_instance.is_caller_external().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/auth/mod.rs","byte_start":639,"byte_end":671,"line_start":25,"line_end":25,"column_start":9,"column_end":41,"is_primary":false,"text":[{"text":"    let (auth_instance, _, _, _, wallet) = get_contracts().await;","highlight_start":9,"highlight_end":41}],"label":"consider giving this pattern the explicit type `(_, _, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/auth/mod.rs","byte_start":714,"byte_end":727,"line_start":26,"line_end":26,"column_start":18,"column_end":31,"is_primary":true,"text":[{"text":"    let result = auth_instance","highlight_start":18,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/auth/mod.rs:26:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (auth_instance, _, _, _, wallet) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = auth_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/auth/mod.rs","byte_start":933,"byte_end":976,"line_start":37,"line_end":37,"column_start":9,"column_end":52,"is_primary":false,"text":[{"text":"    let (_, auth_id, caller_instance, caller_id, _) = get_contracts().await;","highlight_start":9,"highlight_end":52}],"label":"consider giving this pattern the explicit type `(_, _, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/auth/mod.rs","byte_start":1020,"byte_end":1035,"line_start":39,"line_end":39,"column_start":18,"column_end":33,"is_primary":true,"text":[{"text":"    let result = caller_instance","highlight_start":18,"highlight_end":33}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/auth/mod.rs:39:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (_, auth_id, caller_instance, caller_id, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = caller_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/call_frames/mod.rs","byte_start":871,"byte_end":885,"line_start":28,"line_end":28,"column_start":9,"column_end":23,"is_primary":false,"text":[{"text":"    let (instance, id) = get_call_frames_instance().await;","highlight_start":9,"highlight_end":23}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/call_frames/mod.rs","byte_start":939,"byte_end":947,"line_start":29,"line_end":29,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_id().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/call_frames/mod.rs:29:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (instance, id) = get_call_frames_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_id().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/call_frames/mod.rs","byte_start":1071,"byte_end":1086,"line_start":35,"line_end":35,"column_start":9,"column_end":24,"is_primary":false,"text":[{"text":"    let (instance, _id) = get_call_frames_instance().await;","highlight_start":9,"highlight_end":24}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/call_frames/mod.rs","byte_start":1140,"byte_end":1148,"line_start":36,"line_end":36,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_code_size().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/call_frames/mod.rs:36:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (instance, _id) = get_call_frames_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_code_size().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/call_frames/mod.rs","byte_start":1291,"byte_end":1306,"line_start":42,"line_end":42,"column_start":9,"column_end":24,"is_primary":false,"text":[{"text":"    let (instance, _id) = get_call_frames_instance().await;","highlight_start":9,"highlight_end":24}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/call_frames/mod.rs","byte_start":1360,"byte_end":1368,"line_start":43,"line_end":43,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_first_param().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/call_frames/mod.rs:43:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (instance, _id) = get_call_frames_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_first_param().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/call_frames/mod.rs","byte_start":1514,"byte_end":1529,"line_start":49,"line_end":49,"column_start":9,"column_end":24,"is_primary":false,"text":[{"text":"    let (instance, _id) = get_call_frames_instance().await;","highlight_start":9,"highlight_end":24}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/call_frames/mod.rs","byte_start":1583,"byte_end":1591,"line_start":50,"line_end":50,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_second_param().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/call_frames/mod.rs:50:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (instance, _id) = get_call_frames_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_second_param().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":1521,"byte_end":1579,"line_start":51,"line_end":51,"column_start":9,"column_end":67,"is_primary":false,"text":[{"text":"    let (context_instance, context_id, caller_instance, caller_id) = get_contracts().await;","highlight_start":9,"highlight_end":67}],"label":"consider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/context/mod.rs","byte_start":1636,"byte_end":1651,"line_start":54,"line_end":54,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    caller_instance","highlight_start":5,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:54:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (context_instance, context_id, caller_instance, caller_id) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    caller_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":2203,"byte_end":2252,"line_start":79,"line_end":79,"column_start":9,"column_end":58,"is_primary":false,"text":[{"text":"    let (context_instance, _, caller_instance, caller_id) = get_contracts().await;","highlight_start":9,"highlight_end":58}],"label":"consider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/context/mod.rs","byte_start":2309,"byte_end":2324,"line_start":82,"line_end":82,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    caller_instance","highlight_start":5,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:82:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (context_instance, _, caller_instance, caller_id) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    caller_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":2702,"byte_end":2737,"line_start":100,"line_end":100,"column_start":9,"column_end":44,"is_primary":false,"text":[{"text":"    let (_, context_id, caller_instance, _) = get_contracts().await;","highlight_start":9,"highlight_end":44}],"label":"consider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/context/mod.rs","byte_start":2794,"byte_end":2809,"line_start":103,"line_end":103,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    caller_instance","highlight_start":5,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:103:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (_, context_id, caller_instance, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    caller_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":3174,"byte_end":3217,"line_start":121,"line_end":121,"column_start":9,"column_end":52,"is_primary":false,"text":[{"text":"    let (_, context_id, caller_instance, caller_id) = get_contracts().await;","highlight_start":9,"highlight_end":52}],"label":"consider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/context/mod.rs","byte_start":3274,"byte_end":3289,"line_start":124,"line_end":124,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    caller_instance","highlight_start":5,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:124:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (_, context_id, caller_instance, caller_id) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m124\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    caller_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":3728,"byte_end":3763,"line_start":143,"line_end":143,"column_start":9,"column_end":44,"is_primary":false,"text":[{"text":"    let (_, context_id, caller_instance, _) = get_contracts().await;","highlight_start":9,"highlight_end":44}],"label":"consider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/context/mod.rs","byte_start":3820,"byte_end":3835,"line_start":146,"line_end":146,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    caller_instance","highlight_start":5,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:146:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (_, context_id, caller_instance, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    caller_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/context/mod.rs","byte_start":4269,"byte_end":4304,"line_start":165,"line_end":165,"column_start":9,"column_end":44,"is_primary":false,"text":[{"text":"    let (_, context_id, caller_instance, _) = get_contracts().await;","highlight_start":9,"highlight_end":44}],"label":"consider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/context/mod.rs","byte_start":4361,"byte_end":4376,"line_start":168,"line_end":168,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    caller_instance","highlight_start":5,"highlight_end":20}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/context/mod.rs:168:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m165\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (_, context_id, caller_instance, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    caller_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":538,"byte_end":560,"line_start":19,"line_end":19,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;","highlight_start":9,"highlight_end":31}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/reentrancy/mod.rs","byte_start":714,"byte_end":731,"line_start":22,"line_end":22,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = attacker_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:22:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = attacker_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":1140,"byte_end":1162,"line_start":37,"line_end":37,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;","highlight_start":9,"highlight_end":31}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/reentrancy/mod.rs","byte_start":1303,"byte_end":1320,"line_start":40,"line_end":40,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"    attacker_instance","highlight_start":5,"highlight_end":22}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:40:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    attacker_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":1637,"byte_end":1659,"line_start":52,"line_end":52,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;","highlight_start":9,"highlight_end":31}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/reentrancy/mod.rs","byte_start":1800,"byte_end":1817,"line_start":55,"line_end":55,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"    attacker_instance","highlight_start":5,"highlight_end":22}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:55:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    attacker_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/reentrancy/mod.rs","byte_start":2084,"byte_end":2106,"line_start":66,"line_end":66,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;","highlight_start":9,"highlight_end":31}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/reentrancy/mod.rs","byte_start":2260,"byte_end":2277,"line_start":69,"line_end":69,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = attacker_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/reentrancy/mod.rs:69:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (attacker_instance, _) = get_attacker_instance(provider.clone(), wallet.clone()).await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = attacker_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":990,"byte_end":998,"line_start":31,"line_end":31,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":1058,"byte_end":1066,"line_start":32,"line_end":32,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_overflow().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:32:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_overflow().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":1201,"byte_end":1209,"line_start":38,"line_end":38,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":1269,"byte_end":1277,"line_start":39,"line_end":39,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_program_counter().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:39:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_program_counter().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":1430,"byte_end":1438,"line_start":45,"line_end":45,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":1498,"byte_end":1506,"line_start":46,"line_end":46,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_stack_start_ptr().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:46:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_stack_start_ptr().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":1653,"byte_end":1661,"line_start":52,"line_end":52,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":1721,"byte_end":1729,"line_start":53,"line_end":53,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_stack_ptr().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:53:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_stack_ptr().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":1870,"byte_end":1878,"line_start":59,"line_end":59,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":1938,"byte_end":1946,"line_start":60,"line_end":60,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_frame_ptr().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:60:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_frame_ptr().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":2086,"byte_end":2094,"line_start":66,"line_end":66,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":2154,"byte_end":2162,"line_start":67,"line_end":67,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_heap_ptr().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:67:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_heap_ptr().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":2298,"byte_end":2306,"line_start":73,"line_end":73,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":2366,"byte_end":2374,"line_start":74,"line_end":74,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_error().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:74:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m74\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_error().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":2501,"byte_end":2509,"line_start":80,"line_end":80,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":2569,"byte_end":2577,"line_start":81,"line_end":81,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_global_gas().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:81:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m80\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_global_gas().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":2721,"byte_end":2729,"line_start":87,"line_end":87,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":2789,"byte_end":2797,"line_start":88,"line_end":88,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_context_gas().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:88:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_context_gas().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":2938,"byte_end":2946,"line_start":94,"line_end":94,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":3006,"byte_end":3014,"line_start":95,"line_end":95,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_balance().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:95:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_balance().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":3145,"byte_end":3153,"line_start":101,"line_end":101,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":3213,"byte_end":3221,"line_start":102,"line_end":102,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_instrs_start().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:102:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_instrs_start().call().await.unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":3368,"byte_end":3376,"line_start":108,"line_end":108,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":3436,"byte_end":3444,"line_start":109,"line_end":109,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_return_value().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:109:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_return_value().call().await.unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":3581,"byte_end":3589,"line_start":115,"line_end":115,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":3649,"byte_end":3657,"line_start":116,"line_end":116,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_return_length().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:116:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_return_length().call().await.unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/registers/mod.rs","byte_start":3787,"byte_end":3795,"line_start":122,"line_end":122,"column_start":9,"column_end":17,"is_primary":false,"text":[{"text":"    let instance = deploy_test_registers_instance().await;","highlight_start":9,"highlight_end":17}],"label":"consider giving `instance` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/registers/mod.rs","byte_start":3855,"byte_end":3863,"line_start":123,"line_end":123,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    let result = instance.get_flags().call().await.unwrap();","highlight_start":18,"highlight_end":26}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/registers/mod.rs:123:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m122\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let instance = deploy_test_registers_instance().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving `instance` a type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m123\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = instance.get_flags().call().await.unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":346,"byte_end":378,"line_start":14,"line_end":14,"column_start":9,"column_end":41,"is_primary":false,"text":[{"text":"    let (fuelcoin_instance, fuelcoin_id) = get_fuelcoin_instance(provider, wallet).await;","highlight_start":9,"highlight_end":41}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/token_ops/mod.rs","byte_start":446,"byte_end":457,"line_start":16,"line_end":16,"column_start":18,"column_end":29,"is_primary":true,"text":[{"text":"    let target = fuelcoin_id.clone();","highlight_start":18,"highlight_end":29}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:16:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (fuelcoin_instance, fuelcoin_id) = get_fuelcoin_instance(provider, wallet).await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let target = fuelcoin_id.clone();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":1045,"byte_end":1077,"line_start":39,"line_end":39,"column_start":9,"column_end":41,"is_primary":false,"text":[{"text":"    let (fuelcoin_instance, fuelcoin_id) = get_fuelcoin_instance(provider, wallet).await;","highlight_start":9,"highlight_end":41}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/token_ops/mod.rs","byte_start":1145,"byte_end":1156,"line_start":41,"line_end":41,"column_start":18,"column_end":29,"is_primary":true,"text":[{"text":"    let target = fuelcoin_id.clone();","highlight_start":18,"highlight_end":29}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:41:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (fuelcoin_instance, fuelcoin_id) = get_fuelcoin_instance(provider, wallet).await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let target = fuelcoin_id.clone();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":1812,"byte_end":1844,"line_start":65,"line_end":65,"column_start":9,"column_end":41,"is_primary":false,"text":[{"text":"    let (fuelcoin_instance, fuelcoin_id) =","highlight_start":9,"highlight_end":41}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/token_ops/mod.rs","byte_start":2008,"byte_end":2019,"line_start":69,"line_end":69,"column_start":20,"column_end":31,"is_primary":true,"text":[{"text":"    let asset_id = fuelcoin_id.clone();","highlight_start":20,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:69:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (fuelcoin_instance, fuelcoin_id) =\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let asset_id = fuelcoin_id.clone();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":3673,"byte_end":3705,"line_start":128,"line_end":128,"column_start":9,"column_end":41,"is_primary":false,"text":[{"text":"    let (fuelcoin_instance, fuelcoin_id) =","highlight_start":9,"highlight_end":41}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/token_ops/mod.rs","byte_start":3893,"byte_end":3904,"line_start":133,"line_end":133,"column_start":20,"column_end":31,"is_primary":true,"text":[{"text":"    let asset_id = fuelcoin_id.clone();","highlight_start":20,"highlight_end":31}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:133:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m128\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (fuelcoin_instance, fuelcoin_id) =\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let asset_id = fuelcoin_id.clone();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/token_ops/mod.rs","byte_start":4460,"byte_end":4492,"line_start":157,"line_end":157,"column_start":9,"column_end":41,"is_primary":false,"text":[{"text":"    let (fuelcoin_instance, fuelcoin_id) =","highlight_start":9,"highlight_end":41}],"label":"consider giving this pattern the explicit type `(_, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/token_ops/mod.rs","byte_start":4626,"byte_end":4637,"line_start":161,"line_end":161,"column_start":36,"column_end":47,"is_primary":true,"text":[{"text":"    let asset_id_array: [u8; 32] = fuelcoin_id.into();","highlight_start":36,"highlight_end":47}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/token_ops/mod.rs:161:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (fuelcoin_instance, fuelcoin_id) =\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m161\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let asset_id_array: [u8; 32] = fuelcoin_id.into();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":937,"byte_end":962,"line_start":30,"line_end":30,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":1006,"byte_end":1023,"line_start":32,"line_end":32,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance.get_tx_type().call().await.unwrap();","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:32:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance.get_tx_type().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":1194,"byte_end":1219,"line_start":39,"line_end":39,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":1361,"byte_end":1378,"line_start":43,"line_end":43,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:43:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":1628,"byte_end":1653,"line_start":54,"line_end":54,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":1725,"byte_end":1742,"line_start":57,"line_end":57,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:57:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":1993,"byte_end":2018,"line_start":68,"line_end":68,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":2161,"byte_end":2178,"line_start":72,"line_end":72,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:72:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":2430,"byte_end":2455,"line_start":83,"line_end":83,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":2598,"byte_end":2615,"line_start":87,"line_end":87,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance.get_tx_maturity().call().await.unwrap();","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:87:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m83\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance.get_tx_maturity().call().await.unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":2758,"byte_end":2783,"line_start":93,"line_end":93,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":2946,"byte_end":2963,"line_start":97,"line_end":97,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:97:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":3157,"byte_end":3182,"line_start":107,"line_end":107,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":3295,"byte_end":3312,"line_start":111,"line_end":111,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:111:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":3510,"byte_end":3535,"line_start":121,"line_end":121,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":3605,"byte_end":3622,"line_start":124,"line_end":124,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:124:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m124\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":3809,"byte_end":3834,"line_start":134,"line_end":134,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":3905,"byte_end":3922,"line_start":137,"line_end":137,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:137:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m137\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":4113,"byte_end":4138,"line_start":147,"line_end":147,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":4211,"byte_end":4228,"line_start":150,"line_end":150,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:150:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":4421,"byte_end":4446,"line_start":160,"line_end":160,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":4539,"byte_end":4556,"line_start":163,"line_end":163,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:163:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m160\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m163\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":4771,"byte_end":4796,"line_start":173,"line_end":173,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":5364,"byte_end":5381,"line_start":188,"line_end":188,"column_start":18,"column_end":35,"is_primary":true,"text":[{"text":"    let result = contract_instance","highlight_start":18,"highlight_end":35}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:188:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m173\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":5589,"byte_end":5614,"line_start":198,"line_end":198,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":5708,"byte_end":5725,"line_start":202,"line_end":202,"column_start":22,"column_end":39,"is_primary":true,"text":[{"text":"    let result_ptr = contract_instance","highlight_start":22,"highlight_end":39}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:202:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result_ptr = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":6385,"byte_end":6415,"line_start":231,"line_end":231,"column_start":9,"column_end":39,"is_primary":false,"text":[{"text":"    let (contract_instance, _, wallet) = get_contracts().await;","highlight_start":9,"highlight_end":39}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":6481,"byte_end":6498,"line_start":234,"line_end":234,"column_start":22,"column_end":39,"is_primary":true,"text":[{"text":"    let result_ptr = contract_instance","highlight_start":22,"highlight_end":39}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:234:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, wallet) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result_ptr = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"type annotations needed for `(_, _, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"test_projects/tx_fields/mod.rs","byte_start":6828,"byte_end":6853,"line_start":249,"line_end":249,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"    let (contract_instance, _, _) = get_contracts().await;","highlight_start":9,"highlight_end":34}],"label":"consider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"test_projects/tx_fields/mod.rs","byte_start":6949,"byte_end":6966,"line_start":253,"line_end":253,"column_start":22,"column_end":39,"is_primary":true,"text":[{"text":"    let result_ptr = contract_instance","highlight_start":22,"highlight_end":39}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type must be known at this point","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed for `(_, _, _)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtest_projects/tx_fields/mod.rs:253:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m249\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let (contract_instance, _, _) = get_contracts().await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mconsider giving this pattern the explicit type `(_, _, _)`, with the type parameters specified\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m253\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let result_ptr = contract_instance\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: type must be known at this point\u001b[0m\n\n"}
{"message":"aborting due to 79 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 79 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0282, E0412, E0433.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0282, E0412, E0433.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}
